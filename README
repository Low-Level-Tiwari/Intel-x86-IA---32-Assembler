This project implements a Lexical Analyzer and Parser for a low-level assembly language. It uses Lex for tokenizing the input and Yacc/Bison for parsing the tokens to validate and process assembly instructions.
Files

1) lex.l :
	This file contains the Lex specifications to tokenize the assembly language input. It defines the following:
		Patterns (regular expressions) for recognizing assembly language syntax, such as:
        		Instructions (mov, sub, add, cmp, etc.)
        		Registers (eax, ebx, etc.)
        		Memory references (dword[ ], [ ])
        		Values (numeric literals)
        		Symbols, strings, and sections (.bss, .data, .text)
        		Punctuation like commas and colons

	Actions:
        	Extracts tokens and assigns them to yylval for further processing in the parse.
        	Sets flags (isReg, isMem, flag) for specific states.

2) parse.y :
	This file contains the Yacc/Bison grammar rules to parse the tokens generated by lex.l. It defines:
		Assembly language constructs:
        		Instructions with operands
        		Registers and memory access
        		Data declarations (db, dd, resb, resd)
        		Sections (.bss, .data, .text)
        		Labels and symbols
		
	Tokens:
        	Tokens are passed from lex.l and processed according to grammar rules.

    	Actions:
        	Processes and validates the structure of assembly instructions.
        	Uses the yylval structure to store token information like operand names.

How It Works : 

    Lexical Analysis:
        lex.l scans the input assembly file and identifies tokens using regular expressions.

    Parsing:
        parse.y uses grammar rules to ensure that the tokenized assembly input conforms to valid syntax.









Usage:
------

1: To get Help->		./assembler -h 
2: To Generate Object code ->	./assembler -o <asm_file> 
3: To Generate Interm.code ->	./assembler -i <asm_file> 
4: To Generate Symbol table ->	./assembler -s <asm_file> 
4: To Save All Files ->		./assembler -s <asm_file> 


